\documentclass[a4paper]{article}

\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
%\usepackage{multirow}
\usepackage[hypcap]{caption} % makes \ref point to top of figures and tables
\usepackage{amsmath}
%\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
%\usepackage{rotating}
%\usepackage{subcaption}
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\ttfamily \footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2                       % sets default tabsize to 2 spaces
}

\renewcommand{\lstlistingname}{Código}	% Listing x -> Código x
\def\lstlistingautorefname{Código}



\begin{document}

\pagenumbering{gobble}
\input{./rosto.tex}

\tableofcontents
\pagebreak

\pagenumbering{arabic}
\section{Introdução}
Este projecto tem como principal objectivo fazer processamento de imagem recorrendo a uma placa Digilent S3 e a uma câmara com interface VGA. A placa Digilent S3 é uma placa de prototipagem com FPGA que nos permite implementar um processador MicroBlaze. O MicroBlaze comunica com a câmara para fazer o processamento da imagem capturada, que é mostrada num monitor através da saída VGA do dispositivo.

A realização do projecto permitirá a aprendizagem de como implementar um \textit{general purpose processor} como o MicroBlaze numa FPGA, como programar (pelo software providenciado pela Xilinx\textregistered) e utilizar periféricos com esse processador (neste caso a câmara). Aprendemos também como fazer algumas operações simples de processamento de imagem, Histograma e Embossing.


\section{Material Utilizado}
\subsection*{Hardware}
\begin{itemize}
\item câmara VGA
\item computador com Xilinx EDK
\item placa Digilent S3 com Xilinx FPGA XC3S1000-4
\item monitor com entrada VGA
\end{itemize}

A placa Digilent S3 conta com 8 LEDs que são usados numa fase inicial do trabalho (Secção~\ref{subsec:LEDs}). Conta também 3 conjuntos de 40 pinos, um dos quais é usado para ligar a placa da câmara à da FPGA.

\subsection*{Software}
O software utilizado neste projecto foi o Xilinx Platform Studio (XPS) e o Xilinx Software Development Kit (SDK), ambos incluídos no Xilinx Embedded Development Kit (EDK). No XPS são feitas as ligações e algumas configurações da FPGA e no SDK é desenvolvido o software para o MicroBlaze.

\section{Especificações do Projecto}

A FPGA (\textit{Field Programmable Gate Array}) utilizada é uma Xilinx XC3S1000-4, isto é, uma FPGA da família Spartan-3, com 1000K (ou seja, 1M) portas de sistema, com \textit{Speed Grade} de -4, que corresponde a \textit{Standard Performance}. O relógio de sistema funciona a 326 MHz, existindo no dispositivo 4 \textit{Digital Clock Managers}, cada um equipado com um \textit{Delay Locked Loop}\cite{bib:s3datasheet}.

A câmara VGA é configurada para trabalhar com uma resolução de $128\times64$ píxeis, e o monitor para mostrar a imagem directamente da câmara, bem como o resultado do processamento que sai do MicroBlaze implementado na FPGA.

O microprocessador MicroBlaze trata-se de uma arquitectura de 32 bits, desenhada para implementação em FPGAs proprietárias da Xilinx\textregistered\cite{bib:microblaze}. O ambiente de desenvolvimento disponibilizado permite configurar as ligações do sistema e dos barramentos de dados, bem como executar binários compilados no próprio ambiente.

\section{Implementação do Projecto}
\subsection{Introdução à FPGA}
\label{subsec:LEDs}
% LEDs a piscar

Esta parte introdutória do projecto pretende uma familiarização com os ambientes de desenvolvimento e a configuração inicial da FPGA de forma a se ter uma melhor preparação para as fases subsequentes do trabalho. Para isso é criado um projecto que visa a implementação de software no processador \textit{softcore} MicroBlaze. O software a implementar permite controlar os LEDs da placa.

Começa-se por criar um novo projecto usando o Xilinx Platform Studio. De seguida, há que definir para que placa e FPGA estamos a desenvolver e ainda qual a \textit{package} e o \textit{speedgrade}. O tipo de interligações escolhido para fazer a interface entre o processador e os dispositivos é PLB (\textit{processor local bus}). Define-se também que o tipo de processador a usar é MicroBlaze a funcionar a uma frequência de 50 MHz e com 32 KB de memória e sem cache.

Até agora o sistema não tem qualquer periférico. O passo seguinte é adicionar um periférico que permita fazer chegar o sinal de controlo do MicroBlaze aos LEDs da placa. Para controlar o LEDs é usado um periférico que já vem definido no catálogo de propriedade intelectual do XPS (IP Catalog): o \textit{XPS General Purpose IO}. A largura deste módulo deverá ser de 8 bits visto que é esse o número de LEDs que existe na placa.

Uma vez criado o periférico é preciso ligá-lo à PLB para que possa comunicar com o MicroBlaze e tornar externas as portas deste dispositivo. De seguida há que reservar uma região da memória do MicroBlaze para comunicação com o novo periférico. Essa região pode ser escolhida automaticamente pelo XPS.

Antes de gerar o \textit{bitstream} falta ainda alterar o ficheiro \texttt{.ucf} para impor as \textit{contraints} adequadas ao projecto, como a frequência de operação e o mapeamento para as portas externas. Neste cado o ficheiro \texttt{.ucf} adequado é fornecido pelos docentes. O \textit{bitstream} pode agora ser gerado (note-se que este processo é demorado, cerca de 10 minutos) e após isso pode exportar-se as configurações de hardware para o SDK. A partir deste ponto o desenvolvimento é feito no SDK.

Está-se agora apto a implementar o software que se queira correr no MicroBlaze. No SDK cria-se um novo \textit{Board Support Package} e um projecto em C a que se adiciona um ficheiro de código \texttt{main\_leds.c}. Após a escrita do código há que gerar o \textit{Linker Script}, que permitirá gerar o executável.

Está tudo preparado para programar a FPGA e correr o executável. Neste caso se tudo for feito correctamente os LEDs da placa deverão acender e apagar sequencialmente como que fazendo um \textit{rotate} de um bit.

\lstinputlisting[language=C, label=code:main_leds, caption=\texttt{main\_leds.c} após alteração]{../main_leds.c}

É pedido que o código do ficheiro \texttt{main\_leds.c} seja alterado de forma a que o \textit{rotate} seja feito no sentido contrário ao original. O código após essa alteração é o \autoref{code:main_leds} e funcionou como previsto.

Este código começa por inicializar a \textit{driver} do periférico GPIO e definir todos os seus sinais como outputs. De seguida, a execução fica ``presa'' num ciclo que cada vez que é executado faz um \textit{rotate} para a direita e depois o MicroBlaze escreve o novo valor para o periférico, que polariza os LEDs apropriadamente. É usado um \textit{delay} entre iterações do ciclo para que os LEDs possam ser vistos a mudar em vez de aparentarem estar todos acesos (com menor intensidade). Este \textit{delay} é feito com um ciclo que faz uma contagem de \texttt{0} ao valor de \texttt{LED\_DELAY}. Como este ciclo está vazio é importante que o código seja compilado sem optimizações porque caso contrário este ciclo pode ser suprimido e os LEDs não terão o comportamento previsto.

\subsection{Interface com a Câmara}
% preparação da câmara para usar nas fases seguintes

O trabalho desta secção é construído sobre o projecto criado na Secção~\ref{subsec:LEDs}. No XPS, começa-se por adicionar nova IP fornecedida em conjunto com o enunciado. Os periféricos adicionados à \textit{bus} são \texttt{VGA\_interface} e \texttt{camera\_interface}. São depois adicionados duas \textit{buses} FSL (\textit{fast simplex link}). O motivo pelo qual se usam \textit{buses} FSL é a aplicação a desenvolver ser uma \textit{time-critical application}. Segundo \cite{bib:appnoteXilinxFSL} nestes casos deve ser usado a \textit{bus} FSL em vez da OPB (\textit{on-chip peripheral bus}) para integrar a IP no MicroBlaze. Fazendo isto é depois possível utilizar funções em C para usar o IP adicionado pelo utilizador (neste caso \texttt{VGA\_interface} e \texttt{camera\_interface}).

O MicroBlaze é configurado para usar um multiplicador de 32 bits, divisão inteira e uma \textit{stream} FSL. De seguida, fazem-se as interligações necessárias entre o MicroBlaze, a interface VGA e a câmara. São ainda actualizadas as \textit{constraints} do ficheiro \texttt{.ucf} do projecto. Gera-se a \textit{bitstream}, que é exportada para o SDK.

Da mesma forma que na Secção~\ref{subsec:LEDs} foi adicionado o ficheiro \texttt{mail\_leds.c}, no SDK adiciona-se agora o ficheiro \texttt{negative.c}. Liga-se a Digilent S3 à placa da câmara, programa-se a FPGA e corre-se o software. No monitor vê-se a imagem da câmara e por baixo a mesma imagem mas com escala de cinzentos invertida.

\subsection{Processamento de Imagem por Software e Hardware}
\subsubsection{Histograma}


\subsubsection{Relevo (\textit{embossing})}

O algoritmo especificado no enunciado é o seguinte:

\[
D' = K \ast I
\]

\[
D = D' - \widetilde{K} \ast I
\]

Onde $I$ é uma matriz $3 \times 3$ que contém a informação relativa a um pixel e aos 8 píxeis adjacentes.

\[ K =
\begin{bmatrix}
-2 & -2 & 0\\
-2 & 6 & 0\\
0 & 0 & 0
\end{bmatrix}
\]

\[\widetilde{K} = 
\begin{bmatrix}
0&0&0\\
0&-6&2\\
0&2&2
\end{bmatrix}
\]

De maneira a não alocar a memória necessária a um buffer intermédio (uma vez que isso excedia as capacidades do dispositivo), compactámos o algoritmo da seguinte maneira:

\[
D = K \ast I - \widetilde{K} \ast I
\]

Como $K_{i,j} = \widetilde{K}_{(2-j),(2-i)}$, fizemos a simplificação adicional de não construir a matriz $\widetilde{K}$.

Uma vez feitas as operações sobre os dados, o resultado é normalizado, de maneira a que o valor mais claro corresponda a um píxel branco, e o mais escuro a um píxel preto.

\lstinputlisting[language=C]{../embossing.c}



\section{Conclusão e Observações}
Embora o projecto não tenha grande utilidade prática na forma em que foi implementado (demasiados componentes de grande dimensão necessários para poder usar e com lenta iniciação) o valor lúdico é importante e não seria complexo adaptar o sistema usado a dimensões muito inferiores e de mais prática utilização. 

A volatilidade da memória da placa obriga a utilização de um computador com o software instalado cada vez que se quer iniciar o sistema. Se for utilizado um tipo de memória não volátil, é possível retirar o computador do sistema. O monitor pode ser trocado por um LCD moderno de muito menores dimensões sem qualquer tipo de redesenho do sistema, desde que tenha uma interface VGA. Finalmente, todo o sistema pode tornar-se portátil com o uso de uma bateria, uma vez que os componentes necessários têm baixo consumo, sendo ainda mais prático se se recorrer a uma placa de prototipagem de menores dimensões ou, no caso da solução VHDL, implementar o hardware descrito pelo código. (EMBORA PROVAVELMENTE ISTO NAO FIQUE FEITO A TEMPO)

Estas alterações são relativamente simples e aumentariam muito a utilidade do projecto se a intenção fosse a de fazer um produto. 
Foi notada a baixa performance da implementação por software, que está limitada pela arquitectura do MicroBlaze e também pela performance da placa onde o MicroBlaze foi implementado. 

No caso deste projecto a implementação por hardware seria claramente a mais adequada. O processamento feito é relativamente simples, o que diminui a vantagem do uso de um\textit{general purpose processor}, que é menos eficiente e tem uma performance muito inferior. É também relativamente fácil de paralelizar ambos os tipos de processamento, o que é ideal para implementações hardware. Na nossa opinião, a utilização de um \textit{general purpose processor} para a implementação final do sistema só seria justificada se a produção fosse de escala extremamente reduzida (o que seria bastante provável)

Voltando ao objectivo lúdico do projecto, permitiu comparar as vantagens e desvantagens de implementações por hardware e software, assim como aprender vários dos componentes e softwares utilizados e entender como são feitos os tipos de processamento de imagem implementados.





\bibliographystyle{plain}
\nocite{labsECom}
\bibliography{xilinx,labsECom}	% no spaces between commas!

\end{document}
